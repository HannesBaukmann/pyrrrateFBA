\documentclass{article}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[USenglish]{babel}
\usepackage{amsmath,amssymb}
\usepackage{fullpage}
%\usepackage{todonotes}


\makeatletter
\providecommand*{\diff}%
   {\@ifnextchar^{\DIfF}{\DIfF^{}}}
\def\DIfF^#1{%
   \mathop{\text{\mathstrut d}}%
      \nolimits^{#1}\gobblespace}
\def\gobblespace{%
      \futurelet\diffarg\opspace}
\def\opspace{%
   \let\DiffSpace\!%
   \ifx\diffarg(%
      \let\DiffSpace\relax
   \else
      \ifx\diffarg[%
         \let\DiffSpace\relax
      \else
         \ifx\diffarg\{%
            \let\DiffSpace\relax
         \fi\fi\fi\DiffSpace}
\makeatother
\newcommand{\intd}{\diff}%             differential "d"
\newcommand{\defeq}{\mathrel{:=}}%     is per definition equal to
\newcommand{\tp}{\top}%                transpose
\newcommand{\kron}{\otimes}%           Kronecker product
\newcommand{\dkron}[2][]{\mathbin{{}_{#1}\negthinspace\kron_{#2}}}% generalized Kronecker product
\newcommand{\setR}{\mathbb{R}}%        real numbers
\newcommand{\expe}{\mathrm{e}}%        Eulers constant

\newcommand{\vectorfont}[1]{\boldsymbol{#1}}%
\newcommand{\greekvectorfont}[1]{\boldsymbol{#1}}%
\newcommand{\matrixfont}[1]{\mathbf{#1}}%


\newcommand{\bvec}{\vectorfont{b}}
\newcommand{\fvec}{\vectorfont{f}}
\newcommand{\gvec}{\vectorfont{g}}
\newcommand{\hvec}{\vectorfont{h}}
\newcommand{\kvec}{\vectorfont{k}}
\newcommand{\uvec}{\vectorfont{u}}
\newcommand{\yvec}{\vectorfont{y}}

\newcommand{\tildeyvec}{\vectorfont{\tilde{y}}}

\newcommand{\dyvec}{\vectorfont{\dot{y}}}
%
\newcommand{\Phivec}{\greekvectorfont{\Phi}}
\newcommand{\Psivec}{\greekvectorfont{\Psi}}
%
\newcommand{\bfrakvec}{\vectorfont{\mathfrak{b}}}
\newcommand{\ffrakvec}{\vectorfont{\mathfrak{f}}}
\newcommand{\kfrakvec}{\vectorfont{\mathfrak{k}}}
\newcommand{\ufrakvec}{\vectorfont{\mathfrak{u}}}
\newcommand{\xfrakvec}{\vectorfont{\mathfrak{x}}}
\newcommand{\yfrakvec}{\vectorfont{\mathfrak{y}}}
%
\newcommand{\tildeyfrakvec}{\vectorfont{\tilde{\mathfrak{y}}}}
\newcommand{\nullvec}{\greekvectorfont{0}}
\newcommand{\lbvec}{\vectorfont{l\negthinspace b}}
\newcommand{\ubvec}{\vectorfont{u\negthinspace b}}
\newcommand{\lbfrakvec}{\vectorfont{\mathfrak{l\negthinspace b}}}
\newcommand{\ubfrakvec}{\vectorfont{\mathfrak{u\negthinspace b}}}
\newcommand{\einsvec}{\vectorfont{1}\negthinspace\negthinspace\vectorfont{1}} % vector of only ones (1,1,...,1)^T
%
\newcommand{\Bmat}{\matrixfont{B}}
\newcommand{\Hmat}{\matrixfont{H}}
\newcommand{\Imat}{\matrixfont{I}}%       identity matrix
\newcommand{\Smat}{\matrixfont{S}}

\newcommand{\Afrakmat}{\matrixfont{\mathfrak{A}}}

\newcommand{\Nullmat}{\matrixfont{0}}



\begin{document}

\begin{center}
	{\Large\textbf{Implementation Details for \texttt{cp\_linprog.py}}}
\end{center}

We have a linear optimal control problem of the form
\begin{subequations}
\begin{align}
\min_{\uvec(\cdot), \yvec (\cdot)} &\int_{t_0}^{t_{\mathrm{end}}} \expe^{-\varphi \cdot t}\cdot \Phivec_1^{\tp} \yvec(t) \intd t + \Phivec_2^{\tp} \yvec(t_0) + \Phivec_3^{\tp} \cdot \yvec(t_{\mathrm{end}})
\label{eq:OC_problem:obj}
\\
\text{s.\,t.} \quad
\dyvec(t) &= \Smat_2 \cdot \uvec(t) + \Smat_4 \cdot \yvec(t)
\label{eq:OC_problem:dyn}
\\
\nullvec &= \Smat_1 \cdot \uvec(t) + \Smat_3 \cdot \yvec(t)
\label{eq:OC_problem:qssa}
\\
\lbvec &\leq \uvec (t)\leq \ubvec
\label{eq:OC_problem:flux_bounds}
\\
\Hmat_{\yvec} \cdot \yvec(t)  + \Hmat_{\uvec}\cdot \uvec(t)&\leq \hvec
\label{eq:OC_problem:mixed}
\\
\nullvec &\leq \yvec(t)
\label{eq:OC_problem:pos}
\\
\Bmat_{\yvec_0} \cdot \yvec(t_0) + \Bmat_{\yvec_{\mathrm{end}}} \cdot \yvec(t_{\mathrm{end}}) &= \bvec_{\mathrm{bndry}}
\label{eq:OC_problem:bndry}
\end{align}
\end{subequations}
and want to approximate its solution using a complete parameterization approach with midpoint rule for the dynamics and trapezoidal rule for the Lagrange part of the objective.
The result will be formulated as a large linear program
\begin{equation}
\begin{split}
\min_{\xfrakvec} &\;\ffrakvec^{\tp} \cdot \xfrakvec\\
\text{s.\,t.}\quad
\Afrakmat_{\leq} \cdot \xfrakvec &\leq \bfrakvec_{\leq}
\\
\Afrakmat_{=} \cdot \xfrakvec &\leq \bfrakvec_{=}
\\
\lbfrakvec &\leq \xfrakvec \leq \ubfrakvec
\end{split}
\label{eq:final_LP}
\end{equation}
We start with the construction of two time grids, one (called $(t_i)_{i=1}^N$) for the dynamic variables $\yvec(\cdot)$ and one (called $(t_m^{\mathrm{s}})_{m=1/2}^{(N-1)+1/2}$) for the controls $\uvec(\cdot)$.
The user-defined parameter $N \geq 2$ defines the number of time steps.
In the program, these will be referenced as \texttt{tt} and \texttt{tt\_shift}.
The entries of this time grids are defined via
\begin{equation*}
\begin{split}
t_m &\defeq t_0 + m \cdot \Delta_t \,,~(m = 0,1,\ldots, N)\,,
\\
t_{m+1/2}^{\mathrm{s}} &\defeq \frac{t_m + t_{m+1}}{2}\,,~(m=0,1,\ldots,N-1)\,,
\end{split}
%\label{eq:}
\end{equation*}
where the time step size $\Delta_t$ is given by $\Delta_t \defeq \frac{t_{\mathrm{end}} - t_0}{N}$.
We introduce approximations to the dynamic and discrete variables in a straightforward way
\[
\yvec_m \approx \yvec (t_m)\,,~(m=0,1,2,\ldots,N)\,\qquad
\uvec_{m+1/2} \approx \uvec (t_{m+1/2}^{\mathrm{s}})\,,~(m=0,1,2,\ldots,N-1)\,.
\]
So, all approximations will be collected in two stacked vectors
\begin{equation*}
\begin{split}
\yfrakvec &\defeq (\yvec_0^{\tp}, \yvec_1^{\tp} , \ldots , \yvec_{N}^{\tp})^{\tp}\,,
\\
\ufrakvec &\defeq (\uvec_{1/2}^{\tp}, \uvec_{1+1/2}^{\tp}, \ldots , \uvec_{(N-1)+1/2}^{\tp})^{\tp}\,.
\end{split}
%\label{eq:}
\end{equation*}
The vector $\xfrakvec$ in \eqref{eq:final_LP} consists of all the discrete approximations $\xfrakvec = (\yfrakvec^{\tp},\ufrakvec^{\tp})^{\tp}$.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Formulation of the Linear Program}

In case that (some of) the system matrices are constant in time (and we use an equidistant time grid), the LP-problem matrices $\Afrakmat_{\leq}$ and $\Afrakmat_{=}$ can efficiently be implemented using the Kronecker product:
\begin{multline*}
\kron \colon \setR^{m_A \times n_A} \times \setR^{m_B \times n_B} \to \setR^{m_A \cdot m_B \times n_A \cdot n_B}\\
\text{with}\quad
\begin{pmatrix} a_{11} & \cdots & a_{1,n_A} \\ \vdots \\ a_{m_A, 1} & \cdots & a_{m_A, n_A}\end{pmatrix}
\kron B \defeq 
\begin{pmatrix} a_{11}\cdot B & \cdots & a_{1,n_A}\cdot B \\ \vdots \\ a_{m_A, 1}\cdot B & \cdots & a_{m_A, n_A} \dot B\end{pmatrix}\,.
\end{multline*}
For the LP-problem matrices and vectors we will treat the part belonging to the dynamic variables and the ones belonging to the control variables separately.
% ______________________________________________________________________________
\subsubsection*{Objective}

The Lagrange part will be approximated using the trapezoidal rule (on the dynamic time grid), i.\,e.:
\[
\int_{t_0}^{t_{\mathrm{end}}} f(t) \intd t
\approx \Delta_t \cdot
\left(\frac{f(t_0)}{2} + f(t_1) + f(t_2) + \cdots + f(t_{N-1} + \frac{f(t_N)}{2}) \right)
\]
That means, that the according part of the objective vector just collects the $\Phivec_1$ entries like
\[
\ffrakvec_{\yfrakvec,\mathrm{Lagrange}} \defeq \Delta_t \cdot 
\begin{pmatrix} \frac{\expe^{-\varphi t_0} \cdot\Phivec_1^{\tp}}{2} & \expe^{-\varphi t_1} \cdot\Phivec_1^{\tp} & \cdots & \expe^{-\varphi t_{N-1}} \cdot\Phivec_1^{\tp} & \frac{\expe^{-\varphi t_N} \cdot\Phivec_1^{\tp}}{2}\end{pmatrix}^{\tp}
\]
For the Mayer part, we just have to add terms for the start and end point:
\[
\ffrakvec_{\yfrakvec,\mathrm{Mayer}} \defeq 
\begin{pmatrix}
	\Phivec_2^{\tp} & \nullvec^{\tp} & \Phivec_3^{\tp}
\end{pmatrix}^{\tp}\,,
\]
such that the (dynamic part of the) objective vector of the resulting LP is given by
\[
\ffrakvec_{\yfrakvec} = \ffrakvec_{\yfrakvec,\mathrm{Lagrange}} + \ffrakvec_{\yfrakvec,\mathrm{Mayer}}\,.
\]

% ______________________________________________________________________________
\subsubsection*{Dynamics}

For the dynamics, we use the midpoint rule:
\[
\dyvec(t) = \fvec(t, \yvec(t), \uvec(t))\qquad\Rightarrow\qquad
\yvec_{m+1} = \yvec_{m} + \Delta_t \cdot \fvec(t_{m+1/2}^s, \tildeyvec_{m+1}^{(1)}, \uvec_{m+1/2})\,\quad (m=0,1,\ldots,N-1)\,,
\]
where 
\[%begin{align*}
\tildeyvec_{m+1}^{(1)} %&
= \yvec_m + \frac{\Delta_t}{2} \cdot \fvec (t_{m+1/2}^s , \tildeyvec_{m+1}^{(1)}, u_{m+1/2})
%\\
%&
= \yvec_m + \frac{\Delta_t}{2} \cdot \Smat_2 \cdot \uvec_{m+1/2} + \frac{\Delta_t}{2} \cdot \Smat_4 \cdot \tildeyvec_{m+1}^{(1)}
\]%end{align*}
is the according intermediate value for the dynamic variables (from the theory of Runge-Kutta methods).
In detail, the update equations for this scheme read
\[
\yvec_{m+1} = \yvec_m + \Delta_t \cdot \Smat_2 \cdot \uvec_{m+1/2} + \Delta_t \cdot \Smat_4 \cdot \tildeyvec_{m+1}^{(1)}
\]
This can be used to eliminate the intermediate values:
\[
\tildeyvec_{m+1}^{(1)} = \frac{\yvec_m + \yvec_{m+1}}{2}\,\quad (m=0,1,\ldots, N-1)\,,
\]
which is in fact exactly the collocation property.
%
For the dynamic updates, this corresponds to the following
\[
%\quad\Leftrightarrow
\left(\Imat_{n_{\yvec}} + \frac{\Delta_t}{2} \cdot \Smat_4 \right) \cdot \yvec_m - \left(\Imat_{n_{\yvec}}- \frac{\Delta_t}{2}\cdot \Smat_4 \right)\cdot\yvec_{m+1} + \Delta_t \cdot \Smat_2 \cdot \uvec_{m+1/2} = \nullvec\,,~(m = 0,1,\ldots,N-1)\,.
\]
In (large-) matrix form, all these equations read
{\small
\begin{multline*}
\begin{pmatrix}
\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4 & -\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4 
  & \Nullmat           & \cdots & \cdots & \Nullmat \\
\Nullmat          & \Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4  & -\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4 & \cdots & \cdots & \Nullmat \\
\vdots            &                    & \ddots             & \ddots &        & \vdots \\
\Nullmat          & \cdots             & \cdots             & &\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4 & -\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4
\end{pmatrix}
\cdot
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
+
\\
\begin{pmatrix}
	\Delta_t \cdot \Smat_2 & \Nullmat               & \cdots   & \Nullmat \\
	\Nullmat               & \Delta_t \cdot \Smat_2 & \cdots   & \Nullmat \\
	\vdots                 &                        & \ddots   & \vdots   \\
	\Nullmat               & \cdots                 & \Nullmat & \Delta_t \cdot \Smat_2
\end{pmatrix}
\cdot
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
=
\begin{pmatrix}
	\nullvec \\
	\nullvec \\
	\vdots \\
	\nullvec 
\end{pmatrix}
\end{multline*}
}
With Kronecker-notation, this becomes
\[
\Afrakmat_{\yvec,\mathrm{dyn}}
\cdot 
\underbrace{
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
}_{\yfrakvec}
+
\underbrace{
\Imat_{N} \kron \Delta_t \cdot \Smat_2
}_{\Afrakmat_{\uvec, \mathrm{dyn}}}
\cdot
\underbrace{
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
}_{\ufrakvec}
= \nullvec\,,
\]
where
\[
\Afrakmat_{\yvec,\mathrm{dyn}} = 
\begin{pmatrix} \Imat_{N} & \Nullmat_{N,n_{\yvec}} \end{pmatrix} \kron \left(\Imat_{n_{\yvec}}+\frac{\Delta_t}{2}\cdot \Smat_4 \right)
+
\begin{pmatrix} \Nullmat_{N,n_{\yvec}} &-\Imat_N \end{pmatrix} \kron \left(\Imat_{n_{\yvec}}-\frac{\Delta_t}{2}\cdot \Smat_4 \right)\,.
%\begin{pmatrix}
%	1      & -1     &  0     & \cdots & \cdots & 0 \\
%	0      &  1     & -1     & \cdots & \cdots & 0 \\
%	\vdots &        & \ddots & \ddots &        & \vdots \\
%	0      & \cdots & \cdots &        & 1      & -1
%\end{pmatrix}
\]

% ______________________________________________________________________________
\subsubsection*{Control Constraints (QSSA rows)}

The constraints of the DAE system need to be fulfilled at the collocation points.
For the midpoint rule, this is exactly the shifted time grid:
\[
\nullvec = \gvec (t, \yvec(t), \uvec(t))
\qquad \Rightarrow\qquad
\nullvec = \gvec(t_{m+1/2}^{\mathrm{s}}, \tildeyvec_{m+1}^{(1)}, \uvec_{m+1/2})\,~(m = 0,1,\ldots,N-1)\,.
\]
%Since we again have no dependency on $\yvec(\cdot)$ in the right-hand-side, his can simply be stated as
Inserting the given constraint term, we get
\[
\nullvec = \Smat_1 \cdot \uvec_{m+1/2} + \Smat_3 \cdot \tildeyvec_{m+1}^{(1)}\,~(m = 0,1,\ldots,N-1)
\]
or with eliminated intermediates
\[
\nullvec = \Smat_1 \cdot \uvec_{m+1/2} + \frac{1}{2}\cdot \Smat_3 \cdot \yvec_m + \frac{1}{2}\cdot \Smat_3 \cdot \yvec_{m+1}\,.
\]
In (large) matrix form:
\[
\frac{1}{2}\cdot 
\begin{pmatrix}
	\Smat_3  & -\Smat_3 & \Nullmat & \cdots & \cdots  & \Nullmat \\
	\Nullmat & \Smat_3  & -\Smat_3 & \cdots & \cdots  & \Nullmat \\
	\vdots   &          & \ddots   & \ddots &         & \vdots   \\
	\Nullmat & \cdots   & \cdots   &        & \Smat_3 & \Smat_3
\end{pmatrix}
\cdot 
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
+
\begin{pmatrix}
	\Smat_1  & \Nullmat & \cdots & \Nullmat \\
	\Nullmat & \Smat_1  & \cdots & \Nullmat \\
	\vdots   &          & \ddots & \vdots   \\
	\Nullmat & \cdots   & \cdots & \Smat_1
\end{pmatrix}
\cdot 
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
= \nullvec
\]
and, again condensed using Kronecker-notation,
\[
\underbrace{
\frac{1}{2} \cdot
\begin{pmatrix}
	1      & -1     &  0     & \cdots & \cdots & 0      \\
	0      &  1     & -1     & \cdots & \cdots & 0      \\
	\vdots &        & \ddots & \ddots &        & \vdots \\
	0      & \cdots & \cdots &        & 1      & -1
\end{pmatrix}
\kron \Smat_3
}_{\Afrakmat_{\yvec,\mathrm{qssa}}} 
\cdot 
\underbrace{
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
}_{\yfrakvec}
+
\underbrace{
\Imat_{N} \kron \Smat_1
}_{\Afrakmat_{\uvec, \mathrm{qssa}}}
\cdot 
\underbrace{
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
}_{\ufrakvec}
= \nullvec\,.
\]

% ______________________________________________________________________________
\subsubsection*{Control Bounds}

The bounds on the control variables just need to be applied at very time step:
\[
\lbfrakvec_{\uvec}
= \begin{pmatrix} 	\lbvec^{\tp} & \lbvec^{\tp} & \cdots & \lbvec^{\tp} \end{pmatrix}^{\tp}
\,\quad
\ubfrakvec_{\uvec}
= \begin{pmatrix} 	\ubvec^{\tp} & \ubvec^{\tp} & \cdots & \ubvec^{\tp} \end{pmatrix}^{\tp}
\]
in order to implement
\[
\lbvec \leq \uvec_{m+1/2} \leq \ubvec \quad (m = 0, 1, \ldots,N-1)
\]
in the form $\lbfrakvec_{\uvec} \leq \ufrakvec \leq \ubfrakvec$.
% ______________________________________________________________________________
\subsubsection*{Mixed Constraints}

%The mixed constraints require that we first take a closer look at the Runge-Kutta updates inherent in the midpoint rule.
The mixed constraints, just like the flux constraints, need to be enforced on the shifted time grid.
That means, an inequality constraint of the form
\[
\nullvec \leq \gvec_{\leq} (t, \yvec(t), \uvec(t))
\]
is discretized to
\begin{equation}
\nullvec = \gvec (t_{m+1/2}^{\mathrm{s}}, \tildeyvec_{m+1}^{(1)}, \uvec_{m+1/2})\,,~(m = 0,1,\ldots,N-1)\,.
\label{eq:inequality_at_colloc}
\end{equation}
%Since the mixed inequalities explicitly contain the intermediate values $\tildeyvec_{m+1}^{(1)}$, we need to find a simple expression for them.
%Formally, they are introduced as
%\begin{align*}
%\tildeyvec_{m+1}^{(1)} &= \yvec_m + \Delta_t \cdot \frac{1}{2} \cdot \fvec (t_{m+1/2}^{\mathrm{s}}, \tildeyvec_{m+1}^{(1)}, \uvec_{m+1/2})
%  = \yvec_m + \Delta_t \cdot \frac{1}{2} \cdot \Smat_2 \cdot \uvec_{m+1/2}\,.
%\\
%\intertext{At the same time, we get from the discretization of the dynamic equations}
%\yvec_{m+1} &= \yvec_m + \Delta_t \cdot \Smat_2 \cdot \uvec_{m+1/2}\,,
%\end{align*}
%which allows us to eliminate the control variables, giving
%\[
%\tildeyvec_{m+1}^{(1)} = \frac{\yvec_m + \yvec_{m+1}}{2}\,~(m = 0,1,\ldots,N-1)\,.
%\]
%(This is exactly the collocation property of the midpoint rule.)
%So, \eqref{eq:inequality_at_colloc} can be simplified in case of the midpoint rule to
%\[
%\nullvec \leq \gvec_{\leq} \left(t_{m+1/2}^{\mathrm{s}}, \frac{\yvec_m+\yvec_{m+1}}{2}, \uvec_{m+1/2} \right)\,,~(m=0,1,\ldots,N-1).
%\]
For the given linear structure of the mixed constraints \eqref{eq:OC_problem:mixed}, this reads
\[
\Hmat_{\yvec} \cdot \tildeyvec_{m+1}^{(1)}  + \Hmat_{\uvec}\cdot  \uvec_{m+1/2}
= 
\Hmat_{\yvec} \cdot \frac{\yvec_m+\yvec_{m+1}}{2}  + \Hmat_{\uvec}\cdot  \uvec_{m+1/2} \leq \hvec
\]
and can, once again, be restated as
\[
\frac{1}{2} \cdot
\begin{pmatrix}
	\Hmat_{\yvec} & \Hmat_{\yvec} & \Nullmat      & \cdots        & \Nullmat\\
	\Nullmat      & \Hmat_{\yvec} & \Hmat_{\yvec} & \cdots        & \Nullmat\\
	\vdots        &               & \ddots        & \ddots        & \vdots \\
	\Nullmat      & \cdots        & \cdots        & \Hmat_{\yvec} & \Hmat_{\yvec}
\end{pmatrix}
\cdot 
\begin{pmatrix} 	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N \end{pmatrix}
+
\begin{pmatrix}
	\Hmat_{\uvec} & \Nullmat      & \cdots & \Nullmat \\
	\Nullmat      & \Hmat_{\uvec} &        & \Nullmat \\
	\vdots        &               & \ddots & \vdots   \\
	\Nullmat      & \cdots        & \cdots & \Hmat_{\uvec}
\end{pmatrix}
\cdot 
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
\leq
\begin{pmatrix} \hvec \\\hvec \\ \vdots \\\hvec \end{pmatrix}
\]
or in Kronecker form
\[
\underbrace{
\frac{1}{2} \cdot \begin{pmatrix}
	1       & 1      & 0      & \cdots  & 0 \\
	0       & 1      & 1      & \cdots  & 0 \\
	\vdots  &        & \ddots & \ddots  & \vdots \\
	0       & \cdots & \cdots &  1      & 1
\end{pmatrix}
\kron \Hmat_{\yvec}
}_{\Afrakmat_{\yvec,\mathrm{mix}}}
\cdot
\underbrace{
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
}_{\yfrakvec}
+
\underbrace{
\Imat_N \kron \Hmat_{\uvec}}_{\Afrakmat_{\uvec,\mathrm{mix}}}
\cdot 
\underbrace{
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
}_{\ufrakvec}
\leq 
\underbrace{
\begin{pmatrix}
	\hvec \\ \hvec\\ \vdots \\ \hvec
\end{pmatrix}
}_{\bfrakvec_{\mathrm{mix}}} \,.
\]


% ______________________________________________________________________________
\subsubsection*{Positivity of Dynamic Variables}

Requiring that the dynamic variables are positive at all time steps is simple. 
We just implement them as lower bounds. 
(Technically speaking, we would require positivity again for the intermediate values only but this is again equivalent.)
\[
\lbfrakvec_{\yvec} = 
\begin{pmatrix} \nullvec_{n_{\yvec}}^{\tp} & \nullvec_{n_{\yvec}}^{\tp} & \cdots & \nullvec_{n_{\yvec}}^{\tp} \end{pmatrix}^{\tp}\,,\quad
\ubfrakvec_{\yvec}=
\begin{pmatrix} \infty & \infty & \cdots & \infty	 \end{pmatrix}^{\tp}\,.
\]


% ______________________________________________________________________________
\subsubsection*{Boundary Conditions}

Imposing the boundary constraints \eqref{eq:OC_problem:bndry} requires only to couple the initial and end approximations of the dynamical variables:
\[
\Bmat_{\yvec_0} \cdot \yvec_0 + \Bmat_{\yvec_{\mathrm{end}}} \cdot \yvec_N = \bvec_{\mathrm{bndry}}\,.
\]
For the LP form, this can be written in (large) matrix form
\[
\underbrace{
\begin{pmatrix} \Bmat_{\yvec_0} & \Nullmat & \cdots & \Nullmat & \Bmat_{\yvec_{\mathrm{end}}}\end{pmatrix}
}_{\Afrakmat_{\yvec,\mathrm{bndry}}}
\cdot
\underbrace{
\begin{pmatrix}
	\yvec_0 \\ \yvec_1 \\ \vdots \\ \yvec_N
\end{pmatrix}
}_{\yfrakvec}
+
\underbrace{\Nullmat}_{\Afrakmat_{\uvec,\mathrm{bndry}}}
\cdot 
\underbrace{
\begin{pmatrix}
	\uvec_{1/2} \\ \uvec_{1+1/2} \\ \vdots \\ \uvec_{(N-1)+1/2}
\end{pmatrix}
}_{\ufrakvec}
=
\bvec_{\mathrm{bndry}}
\]


% ______________________________________________________________________________
\subsubsection*{Putting it all together}

For the final formulation of the LP, we collect all the information like
\begin{align*}
\ffrakvec &= \begin{pmatrix} \ffrakvec_{\yvec}^{\tp} & \nullvec^{\tp} \end{pmatrix}^{\tp}\,,
\\
\Afrakmat_{\leq} &= \begin{pmatrix} \Afrakmat_{\yvec,\mathrm{mix}}, \Afrakmat_{\uvec,\mathrm{mix}} \end{pmatrix}\,,
\\
\bfrakvec_{\leq} &= \bfrakvec_{\mathrm{mix}}
\\
\Afrakmat_{=} &= \begin{pmatrix} 
                     \Afrakmat_{\yvec, \mathrm{dyn}} & \Afrakmat_{\uvec, \mathrm{dyn}} \\
                     \Afrakmat_{\yvec, \mathrm{qssa}} & \Afrakmat_{\uvec, \mathrm{qssa}} \\
                     \Afrakmat_{\yvec, \mathrm{bndry}} & \Afrakmat_{\uvec, \mathrm{bndry}}
                 \end{pmatrix}
\\
\bfrakvec_{=} &= \begin{pmatrix} \nullvec^{\tp} & \nullvec^{\tp} & \bvec_{\mathrm{bndry}}^{\tp}\end{pmatrix}^{\tp}
\\
\lbfrakvec &= \begin{pmatrix} \lbfrakvec_{\yvec}^{\tp} & \lbfrakvec_{\uvec}^{\tp} \end{pmatrix}^{\tp}
\\
\ubfrakvec &= \begin{pmatrix} \ubfrakvec_{\yvec}^{\tp} & \ubfrakvec_{\uvec}^{\tp} \end{pmatrix}^{\tp}\,.
\end{align*}



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section*{Extension 1 --- Runge-Kutta Methods}

We extend the OC problem with additional terms in the objective (control dependent), the dynamics (state/control-independent terms), and the boundary constraints (control-dependent terms).
\begin{subequations}
	\begin{align}
	\min_{\uvec(\cdot), \yvec (\cdot)} &\int_{t_0}^{t_{\mathrm{end}}} \expe^{-\varphi \cdot t}\cdot \left(\Phivec_1^{\tp}\cdot \yvec(t) + \Phivec_{1,\uvec}^{\tp}\cdot\uvec(t)\right) \intd t + \Phivec_2^{\tp}\cdot \yvec(t_0) + \Phivec_3^{\tp} \cdot \yvec(t_{\mathrm{end}})
	\label{eq:ex_OC_problem:obj}
	\\
	\text{s.\,t.} \quad
	\dyvec(t) &= \Smat_2 \cdot \uvec(t) + \Smat_4 \cdot \yvec(t) + \fvec_2
	\label{eq:ex_OC_problem:dyn}
	\\
	\nullvec &= \Smat_1 \cdot \uvec(t) + \Smat_3 \cdot \yvec(t) + \fvec_1
	\label{eq:ex_OC_problem:qssa}
	\\
	\lbvec &\leq \uvec (t)\leq \ubvec
	\label{eq:ex_OC_problem:flux_bounds}
	\\
	\Hmat_{\yvec} \cdot \yvec(t)  + \Hmat_{\uvec}\cdot \uvec(t)&\leq \hvec
	\label{eq:ex_OC_problem:mixed}
	\\
	%\Hmat_{\yvec,=} \cdot \yvec(t)  + \Hmat_{\uvec,=}\cdot \uvec(t)&= \hvec_{=}
    %\label{eq:ex_OC_problem:mixed_eq}
    %\\
	\nullvec &\leq \yvec(t)
	\label{eq:ex_OC_problem:pos}
	\\
	\bvec_{\mathrm{bndry}} &=
	\Bmat_{\yvec_0} \cdot \yvec(t_0) + \Bmat_{\yvec_{\mathrm{end}}} \cdot \yvec(t_{\mathrm{end}}) + \Bmat_{\uvec_0} \cdot \uvec(t_0) + \Bmat_{\uvec_{\mathrm{end}}} \cdot \uvec(t_{\mathrm{end}}) 
	\label{eq:ex_OC_problem:bndry}
	\end{align}
\end{subequations}
%
\subsection*{Dynamics}
%
Still using a complete parameterization approach, we will now set up more complex time integration schemes, namely Runge-Kutta methods.
That means: We are given a set of parameters (Butcher-tableau) $\begin{array}{r|l}c & A\\\hline & b\end{array}$ with $A \in \setR^{s \times s}$ and define the time integration through the formulae
\begin{equation}
\begin{split}
\tildeyvec_{m+1}^{(i)} &= \yvec_{m} + \Delta_t \cdot \sum_{j=1}^s a_{ij} \cdot \kvec_{m+1}^{(j)} \\
\kvec_{m+1}^{(j)} &= \fvec \left(t_{m+1}^{(j)}, \tildeyvec_{m+1}^{(j)}, \uvec_{m+1}^{(j)}  \right)\\
\yvec_{m+1} &= \yvec_m + \Delta_t \cdot \sum_{i=1}^s b_i \cdot \kvec_{m+1}^{(i)}
\end{split} 
\label{eq:RK_scheme}
\end{equation}
where $t_{m+1}^{(j)} \defeq t_m + c_j \cdot \Delta_t$.
There is some degree of freedom on how to choose the variables here.
The first two equations can be used to eliminate either the stage values $\tildeyvec_{m+1}^{(i)}$ or the slope values $\kvec_{m+1}^{(i)}$.
If the first approach is chosen, we end up with
\begin{align*}
\kvec_{m+1}^{(i)} &= \fvec \left(t_{m+1}^{(i)}, \yvec_{m} + \Delta_t \cdot \sum_{j=1}^s a_{ij} \cdot \kvec_{m+1}^{(j)}, \uvec_{m+1}^{(i)}\right)
\\
 &= \Smat_2 \cdot \uvec_{m+1}^{(i)} + \Smat_4 \cdot \left(\yvec_m + \Delta_t \cdot \sum_{j=1}^s a_{ij}\cdot \kvec_{m+1}^{(j)}\right) + \fvec_2
\\
\Rightarrow~~
-\fvec_2 &= \Smat_2 \cdot \uvec_{m+1}^{(i)} + \Smat_4 \cdot \yvec_m + \Delta_t \cdot \left(\sum_{j=1}^s a_{ij} \cdot \Smat_4 \cdot \kvec_{m+1}^{(j)}\right) - \kvec_{m+1}^{(i)}\,,\quad
(m=0,1,\ldots, N-1)
\end{align*}
Using the Kronecker product, these $s$ sets of equations can be assembled as
\[
(\einsvec_s \kron (-\fvec_2)) = (\einsvec_s \kron \Smat_4) \cdot \yvec_m  + \left( \Delta_t (A \kron \Smat_4) - \Imat_{s\cdot n_{\yvec}}\right)\cdot \kfrakvec^{(m+1)} + (\Imat_s \kron \Smat_2) \cdot \ufrakvec^{(m+1)}
\]
where $\einsvec_s \defeq (1,1,\ldots,1)^{\tp} \in \setR^s$ denotes the vector of only ones and
\begin{equation*}
\kfrakvec^{(m+1)} \defeq (\kvec_{m+1}^{(1)}, \kvec_{m+1}^{(2)}, \ldots, \kvec_{m+1}^{(s)})^{\tp}\,,
\quad
\ufrakvec^{(m+1)} \defeq (\uvec_{m+1}^{(1)}, \uvec_{m+1}^{(2)}, \ldots, \uvec_{m+1}^{(s)})^{\tp}\,.
\end{equation*}
On all time steps, this extends further to
\[
-\einsvec_{N\cdot s}\kron \fvec_2
 = \left(((\Imat_N ,\nullvec_N)\kron \einsvec_s) \kron \Smat_4 \right) \cdot \yfrakvec
  + \left( \Delta_t \cdot ((\Imat_N \kron A)\kron \Smat_4) - \Imat_{N\cdot s \cdot n_{\yvec}}\right)\cdot \kfrakvec  + (\Imat_{N\cdot s}\kron \Smat_2) \cdot \ufrakvec
\]
Here, we introduce the vectors
\[
\kfrakvec \defeq (\kfrakvec^{(0)}, \kfrakvec^{(1)}, \ldots , \kfrakvec^{(N)})^{\tp}\,,\quad
\ufrakvec \defeq (\ufrakvec^{(0)}, \ufrakvec^{(1)}, \ldots , \ufrakvec^{(N)})^{\tp}
\]
The updates of the state approximations give furthermore 
\[
\left(
%\begin{pmatrix}
% 1      & -1     &  0     & \cdots & \cdots & 0      \\
% 0      &  1     & -1     & \cdots & \cdots & 0      \\
% \vdots &        & \ddots & \ddots &        & \vdots \\
% 0      & \cdots & \cdots &        & 1      & -1
%\end{pmatrix}
((\Imat_N, \nullvec_N) - (\nullvec_N, \Imat_N)) \kron \Imat_{n_{\yvec}}
\right) \cdot \yfrakvec 
+ \Delta_t \cdot  (\Imat_N \kron b \kron \Imat_{n_{\yvec}}) \cdot \kfrakvec = \nullvec
\]
If, on the other hand, the slope variables are eliminated, we introduce the vectors
\[
\tildeyfrakvec^{(m+1)} \defeq (\tildeyvec_{m+1}^{(1)}, \tildeyvec_{m+1}^{(2)}, \ldots, \tildeyvec_{m+1}^{(s)})^{\tp}\,,
\quad
\tildeyfrakvec \defeq (\tildeyfrakvec^{(1)}, \tildeyfrakvec^{(2)}, \ldots, \tildeyfrakvec^{(N)})^{\tp}\,.
\]
The elimination works as follows:
\begin{align*}
\tildeyvec_{m+1}^{(i)} &= \yvec_m + \Delta_t \cdot \sum_{j=1}^s a_{ij} \cdot \fvec(t_{m+1}^{(j)}, \tildeyvec_{m+1}^{(j)}, \uvec_{m+1}^{(j)})
\\
 &= \yvec_m + \Delta_t \cdot \sum_{j=1}^s a_{ij} \cdot \left( \fvec_2  + \Smat_4 \cdot \tildeyvec_{m+1}^{(j)} + \Smat_2 \cdot \uvec_{m+1}^{(j)}\right)\,,\quad i = 1 ,\ldots,s,\, m = 0,\ldots, N-1\,.
\end{align*}
At one time step, this can be summarized to
\[
-\Delta_t \cdot (A\cdot \einsvec_s) \kron \fvec_2 
 = \einsvec_s \kron \yvec_m + \left( \Delta_t \cdot (A \kron \Smat_4) - \Imat_{s \cdot n_{\yvec}} \right)\cdot \tildeyfrakvec^{(m+1)} + \Delta_t \cdot (A \kron \Smat_2) \cdot \ufrakvec^{(m+1)}
\]
for $m = 0,1,\ldots, N-1$ and collectively, one obtains
\[
-\Delta_t \cdot \einsvec_N \kron (A \cdot \einsvec_s) \kron \fvec_2
 = \left( (\Imat_N, \nullvec_N) \kron \einsvec_s \kron \Imat_{n_{\yvec}}\right) \cdot \yfrakvec
   + \left(\Delta_t \cdot (\Imat_N \kron A \kron \Smat_4) - \Imat_{N \cdot s \cdot n_{\yvec}} \right) \cdot \tildeyfrakvec
   + \Delta_t \cdot (\Imat_N \kron A \kron \Smat_2) \cdot \ufrakvec
\]
To implement the state vector updates we use
\[
\yvec_{m+1} = \yvec_{m} + \Delta_t \cdot \sum_{i=1}^s b_i \left(\fvec_2 + \Smat_4 \cdot \tildeyvec_{m+1}^{(i)} ¨+ \Smat_2 \cdot \uvec_{m+1}^{(i)}  \right)
\]
which inflates (using the consistency condition $\sum_{i=1}^s b_i = 1$) to
\[
-\einsvec_N \kron \fvec_2 
 = \left(\left((\Imat_N ,\nullvec_N) - (\nullvec_N, \Imat_N)\right)\kron \Imat_{n_{\yvec}} \right) \cdot \yfrakvec
  + \Delta_t \cdot (\Imat_N \kron b \kron \Smat_4)\cdot \tildeyfrakvec 
  + \Delta_t \cdot (\Imat_N \kron b \kron \Smat_2) \cdot \ufrakvec \,.
\]
%
\subsection*{Objective}
%
The Mayer part in that is once again straightforward; no changes to the above case.
We do now assume, that the same time integration (i.e.\ quadrature) scheme is used for the objective.
For the Lagrange part, this means that we use the rule
\[
\int_{t_0}^{t_{\mathrm{end}}}
\Psivec (t, \yvec(t), \uvec(t)) \intd t
\approx 
L  \defeq 
\sum_{m=0}^{N-1} \sum_{i=1}^s \Delta_t \cdot b_i \cdot \Psivec (t_{m+1}^{(i)}, \tildeyvec_{m+1}^{(i)}, \uvec_{m+1}^{(i)})
\]

If the formulation is based on slope variables, we first have to extract the stage values $\tildeyvec_{m+1}^{(i)}$ from them.
\[
L = \sum_{m=0}^{N-1}\sum_{i=1}^s \Delta_t \cdot b_i \cdot 
\expe^{-\varphi \cdot  t_{m+1}^{(i)}} \cdot \left( \Phivec_1^{\tp} \cdot \left(\yvec_m + \Delta_t \cdot \sum_{j=1}^s a_{ij}\cdot \kvec_{m+1}^{(j)}\right) + \Phivec_{1,\uvec}^{\tp}\cdot \uvec_{m+1}^{(i)} \right)
\]
After rearranging, we end up with an objective value as follows
\begin{align*}
 L &= \sum_{m=0}^{N-1} 
     \left(\sum_{i=1}^s \Delta_t \cdot b_i \cdot \expe^{-\varphi \cdot t_{m+1}^{(i)}} \right)\cdot \Phivec_1^{\tp} \cdot \yvec_m
     \\
     &+ \sum_{m=0}^{N-1} \sum_{j=1}^s \Delta_t^2 \cdot \left( \sum_{i=1}^s  b_i \cdot a_{ij}\cdot \expe^{-\varphi \cdot t_{m+1}^{(i)}} \right)\cdot \Phivec_1^{\tp} \cdot \kvec_{m+1}^{(j)} \\
     & + \sum_{m=0}^{N-1} \sum_{i=1}^s \Delta_t \cdot \expe^{-\varphi \cdot t_{m+1}^{(i)}} \cdot b_i \cdot \Phivec_{1,\uvec}^{\tp}\cdot\uvec_{m+1}^{(i)} 
\end{align*}
If we use stage variables, evaluating the Lagrange part is slightly simpler
\[
L = \sum_{m=0}^{N-1} \sum_{i=1}^s \Delta_t \cdot b_i \cdot \expe^{-\varphi\cdot t_{m+1}^{(i)}}\cdot \Phivec_1^{\tp} \cdot \tildeyvec_{m+1}^{(i)} 
+
\sum_{m=0}^{N-1} \sum_{i=1}^s \Delta_t \cdot b_i \cdot \expe^{-\varphi\cdot t_{m+1}^{(i)}}\cdot \Phivec_{1,\uvec}^{\tp}\cdot \uvec_{m+1}^{(i)}
\]


%
\subsection*{Control Constraints}
%
With the intermediate values (slope or stage) explicitly given, the constraint handling is actually simplified in comparison with the above midpoint rule approach.
We get for the case of slope variables
\[
-\einsvec_{N\cdot s} \kron \fvec_1
 =  ((\Imat_{N},\nullvec_N)\kron \einsvec_s \kron \Smat_3)\cdot \yfrakvec
    + \Delta_t \cdot (\Imat_N \kron A \kron \Smat_3)\cdot \kfrakvec
    + (\Imat_{N\cdot s} \kron \Smat_1)\cdot \ufrakvec 
\]
In the case of stage variables, the control constraints read
\[
-\einsvec_{N\cdot s} \kron \fvec_1
 = (\Imat_{N\cdot s} \kron \Smat_3) \cdot \tildeyfrakvec + (\Imat_{N\cdot s} \kron \Smat_1) \cdot \ufrakvec\,. 
\]
%
\subsection*{Mixed Constraints}
%
The structure here is (due to the introduction of $\Smat_3$ in the dynamics) the same resulting in
\[
 ((\Imat_{N},\nullvec_N)\kron \einsvec_s \kron \Hmat_{\yvec})\cdot \yfrakvec
+ \Delta_t \cdot (\Imat_N \kron A \kron \Hmat_{\yvec})\cdot \kfrakvec
+ (\Imat_{N\cdot s} \kron \Hmat_{\uvec})\cdot \ufrakvec 
\leq
\einsvec_{N\cdot s} \kron \hvec
\]
for slope variables and in
\[
(\Imat_{N\cdot s} \kron \Hmat_{\yvec}) \cdot \tildeyfrakvec + (\Imat_{N\cdot s} \kron \Hmat_{\uvec}) \cdot \ufrakvec \leq \einsvec_{N\cdot s} \kron \hvec
\]
for stage variables.


%
\subsection*{Control Bounds}
%
Again, directly implemented: $\lbvec \leq \uvec_{m+1}^{(i)} \leq \ubvec$ for all $m,i$:
\[
\lbfrakvec_{\uvec} = \einsvec_{N\cdot s} \kron \lbvec\,\quad
\ubfrakvec_{\uvec} = \einsvec_{N\cdot s} \kron \ubvec\,.
\]

%
\subsection*{Positivity}
%
Not as simple as before in the case of slope variables:
For implementing
%\[
$
\tildeyvec_{m+1}^{(i)} = \yvec_m + \Delta_t \cdot \sum_{j=1}^s a_{ij}\cdot \kvec_{m+1}^{(j)}\geq \nullvec
$
%\]
for all $i,m$, we need to add `real' inequality constraints:
\[
-((\Imat_{N} ,\nullvec_N) \kron \einsvec_s \kron \Imat_{n_{\yvec}}) \cdot \yfrakvec - \Delta_t \cdot (\Imat_{N} \kron A \kron \Imat_{n_{\yvec}}) \cdot \kfrakvec \leq \nullvec_{s\cdot N \cdot n_{\yvec}}
\]
If we use stage variables, it remains as straight away as before:
\[
\lbfrakvec_{\tildeyfrakvec} = \nullvec_{N \cdot s \cdot n_{\yvec}}
\]

%
\subsection*{Boundary Values}
%
On the state vector level they are also directly implemented, no surprises.
For the control variables, one first has to define variables for $\uvec(t_0)$ and $\uvec(t_{\mathrm{end}})$ (and potentially connect them to the ones on the control grid).



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section*{Extension 2 --- Time Dependency}

To continue the relatively concise notation, we introduce a new operator.
Let $B \defeq (b_{ij})_{i=1,\ldots,m_B, j=1,\ldots,n_B}$, $T \defeq (t_{ij})_{i=1,\ldots,m_B, j=1,\ldots,n_B}$, $C(t) %\defeq (c_{ij}(t))_{i=1,\ldots,m_C, j=1,\ldots,n_C} 
\colon \setR \to \setR^{m_C \times n_C}$ be three given matrices (the latter dependent on a real parameter).
Then the `d-Kronecker product' is given by
\[
B \dkron{T} C \defeq \begin{pmatrix}
 b_{11} \cdot C(t_{11}) & b_{12}\cdot C(t_{12}) & \cdots & b_{1,n_B} \cdot C(t_{1,n_B}) \\
 \vdots                 & \vdots                &        & \vdots                       \\
 b_{m_B1} \cdot C(t_{m_B1}) & b_{m_B2}\cdot C(t_{m_B2}) & \cdots & b_{m_B,n_B} \cdot C(t_{m_B,n_B}) \\
\end{pmatrix}
\]

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

\section*{Extension 3 --- Arbitrary Time Grid}

\[
B \dkron[h]{T} C(t) \defeq ...
\]

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\subsection*{ToDos and Maybe's}

\begin{itemize}
  \item time-dependent matrices on almost all levels
	%\item additional constant terms in the dynamics and the control constraints
	\item non-equidistant time grid
	\item Add absolute-value constraints/objective terms (e.g. total variation)
	\item It is possible to fully eliminate the state approximations $\yvec_{m}$ from the LP and instead calculate them in a post-processing step.
	But then, (at least) the boundary values and objective are more complicated.
	\item Formulation with stage values instead of slope values
	\item Add terms depending on controls in the objective and the boundary conditions
	\item add quadratic terms in the objective
	\item inequality boundary constraints
	\item inequality mixed constraints/bounds on dynamic variables(?)
	\item Matrix $\Smat_3$ might actually destroy the problem structure if we want to use other algorithms than complete parameterization or eliminate the dependent flux variables later on. So: Is it really worth all this?
	\item more general time integration schemes (multi-step methods)
	\item Using/exploiting FSAL/ $c_i \in \lbrace 0,1\rbrace$?
	\item Are there `elegant' ways to include discrete/Boolean variables and especially indicator variables?
	\item Does it improve stability/Is it necessary to enforce constraint fulfillment at the time instances of the main grid? If so, which control variables are to be used/Do we need to introduce further control variables?
	It should at least be checked if the inequality constraints are fulfilled for $\yvec$.
\end{itemize}


\end{document}
